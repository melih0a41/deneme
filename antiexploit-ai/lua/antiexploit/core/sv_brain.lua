--[[
    AI Brain Module
    Neural network and decision engine
]]

function AntiExploit:InitializeAIBrain()
    -- Initialize AI Brain structure
    self.AIBrain = {
        neural_network = {},
        pattern_memory = {},
        threat_intelligence = {},
        decision_engine = {},
        learning_active = true,
        autonomous_mode = true
    }
    
    -- Neural network setup
    self.AIBrain.neural_network = {
        layers = AntiExploit.Config.NEURAL_LAYERS,
        weights = {},
        biases = {},
        learning_rate = AntiExploit.Config.LEARNING_RATE,
        accuracy = 0,
        training_samples = 0
    }
    
    -- Initialize weights and biases
    for layer = 1, #self.AIBrain.neural_network.layers - 1 do
        local prev_size = self.AIBrain.neural_network.layers[layer]
        local curr_size = self.AIBrain.neural_network.layers[layer + 1]
        
        self.AIBrain.neural_network.weights[layer] = {}
        self.AIBrain.neural_network.biases[layer] = {}
        
        for neuron = 1, curr_size do
            self.AIBrain.neural_network.weights[layer][neuron] = {}
            self.AIBrain.neural_network.biases[layer][neuron] = (math.random() * 2 - 1) * 0.3
            
            for prev_neuron = 1, prev_size do
                self.AIBrain.neural_network.weights[layer][neuron][prev_neuron] = (math.random() * 2 - 1) * 0.3
            end
        end
    end
    
    -- Decision engine
    self.AIBrain.decision_engine = {
        confidence_history = {},
        decision_accuracy = {},
        auto_adjustments = 0,
        learning_cycles = 0
    }
    
    print("[AI Brain] ðŸ§  Neural network initialized (" .. table.concat(self.AIBrain.neural_network.layers, "-") .. ")")
end

function AntiExploit:AIPredict(features)
    -- Nil kontrolu ekle
    if not self.AIBrain or not self.AIBrain.neural_network or not self.AIBrain.neural_network.weights then
        -- Neural network initialize edilmemisse basit bir tahmin yap
        return 0, 0.5 -- Normal sÄ±nÄ±f, orta guven
    end
    
    local activations = self:ForwardPropagation(features)
    if not activations then
        return 0, 0.5
    end
    
    local output = activations[#activations]
    if not output then
        return 0, 0.5
    end
    
    -- Find highest confidence class
    local max_confidence = 0
    local predicted_class = 0
    
    for i = 1, #output do
        if output[i] > max_confidence then
            max_confidence = output[i]
            predicted_class = i - 1
        end
    end
    
    return predicted_class, max_confidence
end

function AntiExploit:ForwardPropagation(inputs)
    -- Nil kontrolleri
    if not self.AIBrain or not self.AIBrain.neural_network then
        return nil
    end
    
    if not self.AIBrain.neural_network.weights or #self.AIBrain.neural_network.weights == 0 then
        -- Weights yok veya bos, yeniden initialize et
        self:InitializeAIBrain()
        if not self.AIBrain.neural_network.weights or #self.AIBrain.neural_network.weights == 0 then
            return nil
        end
    end
    
    local activations = {inputs}
    
    for layer = 1, #self.AIBrain.neural_network.weights do
        local prev_activation = activations[layer]
        local curr_activation = {}
        
        if not self.AIBrain.neural_network.weights[layer] then
            return nil
        end
        
        for neuron = 1, #self.AIBrain.neural_network.weights[layer] do
            local sum = self.AIBrain.neural_network.biases[layer][neuron] or 0
            
            for prev_neuron = 1, #prev_activation do
                local weight = self.AIBrain.neural_network.weights[layer][neuron][prev_neuron] or 0
                sum = sum + prev_activation[prev_neuron] * weight
            end
            
            curr_activation[neuron] = self:Sigmoid(sum)
        end
        
        table.insert(activations, curr_activation)
    end
    
    return activations
end

function AntiExploit:Sigmoid(x)
    return 1 / (1 + math.exp(-math.max(-500, math.min(500, x))))
end

function AntiExploit:Backpropagation(inputs, target_output)
    if not self.AIBrain or not self.AIBrain.neural_network then return end
    
    -- Weights kontrolu
    if not self.AIBrain.neural_network.weights or #self.AIBrain.neural_network.weights == 0 then
        self:InitializeAIBrain()
        return
    end
    
    -- Forward pass
    local activations = self:ForwardPropagation(inputs)
    if not activations then return end
    
    -- Calculate output error
    local output_errors = {}
    local output_layer = activations[#activations]
    
    for i = 1, #output_layer do
        local error = target_output[i] - output_layer[i]
        output_errors[i] = error * output_layer[i] * (1 - output_layer[i])
    end
    
    -- Backpropagate errors
    local layer_errors = {output_errors}
    
    for layer = #self.AIBrain.neural_network.weights, 1, -1 do
        local curr_errors = {}
        local next_errors = layer_errors[1]
        
        for neuron = 1, #self.AIBrain.neural_network.weights[layer][1] do
            local error = 0
            
            for next_neuron = 1, #next_errors do
                error = error + next_errors[next_neuron] * self.AIBrain.neural_network.weights[layer][next_neuron][neuron]
            end
            
            local activation = activations[layer][neuron]
            curr_errors[neuron] = error * activation * (1 - activation)
        end
        
        table.insert(layer_errors, 1, curr_errors)
    end
    
    -- Update weights and biases
    local learning_rate = self.AIBrain.neural_network.learning_rate or 0.01
    
    for layer = 1, #self.AIBrain.neural_network.weights do
        for neuron = 1, #self.AIBrain.neural_network.weights[layer] do
            -- Update bias
            self.AIBrain.neural_network.biases[layer][neuron] = 
                self.AIBrain.neural_network.biases[layer][neuron] + learning_rate * layer_errors[layer + 1][neuron]
            
            -- Update weights
            for prev_neuron = 1, #activations[layer] do
                self.AIBrain.neural_network.weights[layer][neuron][prev_neuron] = 
                    self.AIBrain.neural_network.weights[layer][neuron][prev_neuron] + 
                    learning_rate * layer_errors[layer + 1][neuron] * activations[layer][prev_neuron]
            end
        end
    end
    
    -- Increment training samples
    self.AIBrain.neural_network.training_samples = (self.AIBrain.neural_network.training_samples or 0) + 1
end