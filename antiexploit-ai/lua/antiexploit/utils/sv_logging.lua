--[[
    Logging Module
    Handles all system logging and analytics
]]

-- Initialize logging
function AntiExploit:InitializeLogging()
    if not file.Exists("antiexploit_logs", "DATA") then
        file.CreateDir("antiexploit_logs")
    end
    
    self.LogBuffer = {}
    self.PerformanceLog = {}
    
    -- Periodic log flush
    timer.Create("AntiExploit_LogFlush", 30, 0, function()
        self:FlushLogs()
    end)
end

-- Log autonomous action
function AntiExploit:LogAutonomousAction(threat_type, threat_data, confidence)
    if not self.PerformanceLog then
        self.PerformanceLog = {}
    end
    
    local log_entry = {
        timestamp = os.time(),
        threat_type = threat_type,
        confidence = confidence,
        action_taken = confidence >= AntiExploit.Config.AUTO_WARN_THRESHOLD,
        indicators = threat_data.indicators or {},
        ai_classification = threat_data.ai_classification,
        server_performance = {
            fps = 1 / engine.TickInterval(),
            memory = collectgarbage("count"),
            players = #player.GetAll()
        }
    }
    
    table.insert(self.PerformanceLog, log_entry)
    
    -- Keep only last 1000 entries
    if #self.PerformanceLog > 1000 then
        table.remove(self.PerformanceLog, 1)
    end
    
    -- Save periodically
    if #self.PerformanceLog % 50 == 0 then
        self:SavePerformanceLog()
    end
    
    -- Add to buffer for immediate logging
    self:AddToLogBuffer("ACTION", log_entry)
end

-- Add to log buffer
function AntiExploit:AddToLogBuffer(log_type, data)
    if not self.LogBuffer then
        self.LogBuffer = {}
    end
    
    table.insert(self.LogBuffer, {
        type = log_type,
        data = data,
        timestamp = os.time()
    })
    
    -- Auto-flush if buffer is large
    if #self.LogBuffer > 100 then
        self:FlushLogs()
    end
end

-- Flush logs to file
function AntiExploit:FlushLogs()
    if not self.LogBuffer or #self.LogBuffer == 0 then return end
    
    local date_str = os.date("%Y%m%d")
    local log_file = "antiexploit_logs/log_" .. date_str .. ".txt"
    
    local existing_content = file.Read(log_file, "DATA") or ""
    
    for _, log_entry in ipairs(self.LogBuffer) do
        local timestamp = os.date("%Y-%m-%d %H:%M:%S", log_entry.timestamp)
        local log_line = string.format("[%s] [%s] %s\n", 
            timestamp, 
            log_entry.type,
            util.TableToJSON(log_entry.data))
        
        existing_content = existing_content .. log_line
    end
    
    file.Write(log_file, existing_content)
    
    -- Clear buffer
    self.LogBuffer = {}
end

-- Save performance log
function AntiExploit:SavePerformanceLog()
    if not file.Exists("antiexploit_logs", "DATA") then
        file.CreateDir("antiexploit_logs")
    end
    
    local log_file = "antiexploit_logs/performance_" .. os.date("%Y%m%d") .. ".json"
    local log_data = {
        logs = self.PerformanceLog,
        metrics = self:CalculatePerformanceMetrics(),
        timestamp = os.time()
    }
    
    file.Write(log_file, util.TableToJSON(log_data))
end

-- Calculate performance metrics
function AntiExploit:CalculatePerformanceMetrics()
    local metrics = {
        detection_rate = 0,
        false_positive_rate = 0,
        response_time = 0,
        accuracy = self.AIBrain.neural_network.accuracy or 0,
        threats_detected = 0,
        actions_taken = 0
    }
    
    -- Calculate from logged data
    if self.PerformanceLog then
        local recent_detections = 0
        local false_positives = 0
        local total_actions = 0
        
        for _, log_entry in ipairs(self.PerformanceLog) do
            if log_entry.timestamp > (os.time() - 3600) then -- Last hour
                recent_detections = recent_detections + 1
                
                if log_entry.action_taken then
                    total_actions = total_actions + 1
                end
                
                if log_entry.false_positive then
                    false_positives = false_positives + 1
                end
            end
        end
        
        if recent_detections > 0 then
            metrics.false_positive_rate = false_positives / recent_detections
            metrics.detection_rate = (recent_detections - false_positives) / recent_detections
        end
        
        metrics.threats_detected = recent_detections
        metrics.actions_taken = total_actions
    end
    
    return metrics
end

-- Log error with context
function AntiExploit:LogError(error_msg, context)
    self:AddToLogBuffer("ERROR", {
        message = error_msg,
        context = context,
        stack_trace = debug.traceback()
    })
    
    if AntiExploit.Config.DEBUG_MODE then
        print("[ERROR] " .. error_msg)
    end
end

-- Log debug information
function AntiExploit:LogDebug(message, data)
    if not AntiExploit.Config.DEBUG_MODE then return end
    
    self:AddToLogBuffer("DEBUG", {
        message = message,
        data = data
    })
    
    print("[DEBUG] " .. message)
end

-- Generate daily report
function AntiExploit:GenerateDailyReport()
    local report = {
        date = os.date("%Y-%m-%d"),
        uptime = self:GetServerUptime(),
        metrics = self:CalculatePerformanceMetrics(),
        top_threats = self:GetTopThreats(),
        system_health = self:CalculateSystemHealth()
    }
    
    local report_file = "antiexploit_logs/daily_report_" .. os.date("%Y%m%d") .. ".json"
    file.Write(report_file, util.TableToJSON(report, true))
    
    return report
end

-- Get top threats
function AntiExploit:GetTopThreats()
    local threat_counts = {}
    
    if self.PerformanceLog then
        for _, log_entry in ipairs(self.PerformanceLog) do
            if log_entry.timestamp > (os.time() - 86400) then -- Last 24 hours
                local threat = log_entry.threat_type
                threat_counts[threat] = (threat_counts[threat] or 0) + 1
            end
        end
    end
    
    -- Sort by count
    local sorted_threats = {}
    for threat, count in pairs(threat_counts) do
        table.insert(sorted_threats, {type = threat, count = count})
    end
    
    table.sort(sorted_threats, function(a, b) return a.count > b.count end)
    
    -- Return top 5
    local top_threats = {}
    for i = 1, math.min(5, #sorted_threats) do
        table.insert(top_threats, sorted_threats[i])
    end
    
    return top_threats
end

-- Export logs
concommand.Add("antiexploit_export_logs", function(ply, cmd, args)
    if not ply:IsAdmin() then return end
    
    local export_data = {
        performance_logs = AntiExploit.PerformanceLog,
        metrics = AntiExploit:CalculatePerformanceMetrics(),
        system_info = {
            version = AntiExploit.Version,
            uptime = AntiExploit:GetServerUptime(),
            config = AntiExploit.Config
        },
        export_time = os.time()
    }
    
    local export_file = "antiexploit_logs/export_" .. os.time() .. ".json"
    file.Write(export_file, util.TableToJSON(export_data, true))
    
    ply:ChatPrint("[AntiExploit] Logs exported to: " .. export_file)
end)

-- Initialize logging on startup
hook.Add("Initialize", "AntiExploit_InitLogging", function()
    if AntiExploit then
        AntiExploit:InitializeLogging()
    end
end)