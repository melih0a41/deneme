--[[
    Heuristic Detection Module
    Advanced heuristic analysis for unknown threats
]]

-- Heuristic rules for unknown exploits
AntiExploit.HeuristicRules = {
    -- Rule 1: Suspicious timing patterns
    {
        name = "PERFECT_TIMING",
        check = function(ply, data)
            -- Check if actions are too perfectly timed (bot-like)
            if not data.action_times or #data.action_times < 10 then return 0 end
            
            local intervals = {}
            for i = 2, #data.action_times do
                table.insert(intervals, data.action_times[i] - data.action_times[i-1])
            end
            
            -- Calculate standard deviation
            local avg = 0
            for _, interval in ipairs(intervals) do
                avg = avg + interval
            end
            avg = avg / #intervals
            
            local variance = 0
            for _, interval in ipairs(intervals) do
                variance = variance + math.pow(interval - avg, 2)
            end
            variance = variance / #intervals
            
            local std_dev = math.sqrt(variance)
            
            -- Too consistent = likely automated
            if std_dev < 0.05 and avg < 0.5 then
                return 0.8 -- High confidence
            end
            
            return 0
        end
    },
    
    -- Rule 2: Information gathering behavior
    {
        name = "INFO_GATHERING",
        check = function(ply, data)
            local score = 0
            
            -- Checking multiple players rapidly
            if data.targets_checked and #data.targets_checked > 10 then
                score = score + 0.3
            end
            
            -- Accessing unusual game information
            if data.unusual_queries and data.unusual_queries > 5 then
                score = score + 0.3
            end
            
            -- Scanning behavior
            if data.scan_pattern then
                score = score + 0.4
            end
            
            return math.min(1, score)
        end
    },
    
    -- Rule 3: Resource abuse patterns
    {
        name = "RESOURCE_ABUSE",
        check = function(ply, data)
            local score = 0
            
            -- Rapid entity creation/deletion
            if data.entity_churn_rate and data.entity_churn_rate > 50 then
                score = score + 0.5
            end
            
            -- Memory manipulation attempts
            if data.memory_spikes and data.memory_spikes > 3 then
                score = score + 0.5
            end
            
            return math.min(1, score)
        end
    },
    
    -- Rule 4: Evasion techniques
    {
        name = "EVASION_BEHAVIOR",
        check = function(ply, data)
            local score = 0
            
            -- Name changing rapidly
            if data.name_changes and data.name_changes > 3 then
                score = score + 0.3
            end
            
            -- Reconnect patterns
            if data.reconnects and data.reconnects > 2 then
                score = score + 0.3
            end
            
            -- Spectator abuse
            if data.spectator_switches and data.spectator_switches > 5 then
                score = score + 0.4
            end
            
            return math.min(1, score)
        end
    }
}

-- Advanced pattern matching for unknown exploits
function AntiExploit:AdvancedPatternMatch(ply)
    local steamid = ply:SteamID64()
    local player_data = self.PlayerData[steamid]
    
    if not player_data then return 0, {} end
    
    local total_score = 0
    local triggered_rules = {}
    
    -- Prepare analysis data
    local analysis_data = self:PrepareAnalysisData(ply, player_data)
    
    -- Run each heuristic rule
    for _, rule in ipairs(self.HeuristicRules) do
        local score = rule.check(ply, analysis_data)
        
        if score > 0 then
            total_score = total_score + score
            table.insert(triggered_rules, {
                rule = rule.name,
                confidence = score
            })
        end
    end
    
    -- Normalize score
    total_score = math.min(1, total_score / #self.HeuristicRules)
    
    return total_score, triggered_rules
end

-- Prepare data for heuristic analysis
function AntiExploit:PrepareAnalysisData(ply, player_data)
    local data = {}
    
    -- Action timing data
    data.action_times = {}
    if player_data.commands then
        for _, cmd in ipairs(player_data.commands) do
            if cmd.timestamp then
                table.insert(data.action_times, cmd.timestamp)
            end
        end
    end
    
    -- Target checking behavior
    data.targets_checked = {}
    -- (Would track which players/entities were examined)
    
    -- Entity manipulation
    local owned_ents = 0
    local recent_spawns = 0
    for _, ent in ipairs(ents.GetAll()) do
        if IsValid(ent) and ent:CPPIGetOwner() == ply then
            owned_ents = owned_ents + 1
            if ent.SpawnTime and (CurTime() - ent.SpawnTime) < 60 then
                recent_spawns = recent_spawns + 1
            end
        end
    end
    
    data.entity_churn_rate = recent_spawns
    
    return data
end

-- Signature-less detection
function AntiExploit:SignaturelessDetection(ply)
    -- Statistical anomaly detection
    local statistical_score = self:StatisticalAnomalyDetection(ply)
    
    -- Behavioral clustering
    local cluster_score = self:BehavioralClustering(ply)
    
    -- Machine learning prediction
    local ml_score = self:MLPrediction(ply)
    
    -- Combine scores
    local final_score = (statistical_score * 0.4) + (cluster_score * 0.3) + (ml_score * 0.3)
    
    return final_score
end

-- Statistical anomaly detection
function AntiExploit:StatisticalAnomalyDetection(ply)
    local steamid = ply:SteamID64()
    
    -- Get player's metrics
    local metrics = self:CollectPlayerMetrics(ply)
    
    -- Compare against population statistics
    local z_scores = {}
    
    for metric, value in pairs(metrics) do
        local population_mean = self:GetPopulationMean(metric)
        local population_std = self:GetPopulationStd(metric)
        
        if population_std > 0 then
            local z_score = math.abs((value - population_mean) / population_std)
            table.insert(z_scores, z_score)
        end
    end
    
    -- Calculate anomaly score from z-scores
    local anomaly_score = 0
    for _, z in ipairs(z_scores) do
        if z > 3 then -- 3 standard deviations
            anomaly_score = anomaly_score + 0.3
        elseif z > 2 then
            anomaly_score = anomaly_score + 0.1
        end
    end
    
    return math.min(1, anomaly_score)
end

-- Collect metrics for statistical analysis
function AntiExploit:CollectPlayerMetrics(ply)
    local steamid = ply:SteamID64()
    local player_data = self.PlayerData[steamid]
    
    local metrics = {
        commands_per_minute = 0,
        network_messages_per_minute = 0,
        movement_speed_avg = 0,
        prop_spawn_rate = 0,
        chat_frequency = 0
    }
    
    if not player_data then return metrics end
    
    -- Calculate metrics
    local time_window = 60 -- 1 minute
    local current_time = CurTime()
    
    -- Commands per minute
    local recent_commands = 0
    for _, cmd in ipairs(player_data.commands or {}) do
        if cmd.timestamp and (current_time - cmd.timestamp) < time_window then
            recent_commands = recent_commands + 1
        end
    end
    metrics.commands_per_minute = recent_commands
    
    -- Network messages
    local recent_network = 0
    for _, net in ipairs(player_data.network_activity or {}) do
        if net.time and (current_time - net.time) < time_window then
            recent_network = recent_network + 1
        end
    end
    metrics.network_messages_per_minute = recent_network
    
    return metrics
end

-- Real-time learning from new patterns
function AntiExploit:RealTimeLearning(pattern_data)
    -- Update neural network immediately
    local features = self:ExtractFeaturesFromPattern(pattern_data)
    
    -- Quick training iteration
    for i = 1, 5 do
        self:TrainNeuralNetwork(features, 2) -- Suspicious class
    end
    
    -- Update pattern database
    local pattern_signature = self:GeneratePatternSignature(pattern_data)
    
    if not self.ThreatDatabase.learned_patterns then
        self.ThreatDatabase.learned_patterns = {}
    end
    
    table.insert(self.ThreatDatabase.learned_patterns, {
        signature = pattern_signature,
        first_seen = os.time(),
        occurrences = 1,
        confidence = pattern_data.confidence
    })
    
    print("[Real-Time Learning] New pattern learned: " .. pattern_signature)
end

-- Generate unique signature from pattern
function AntiExploit:GeneratePatternSignature(pattern_data)
    local sig_parts = {}
    
    -- Include key indicators
    for _, indicator in ipairs(pattern_data.indicators or {}) do
        table.insert(sig_parts, indicator)
    end
    
    -- Add timestamp component
    table.insert(sig_parts, os.date("%Y%m%d"))
    
    -- Create hash
    return "RTLEARN_" .. util.CRC(table.concat(sig_parts, "_"))
end

print("[Heuristic Detection] Module loaded - Advanced pattern matching active")