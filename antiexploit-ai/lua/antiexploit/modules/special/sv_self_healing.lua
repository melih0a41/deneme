--[[
    Self-Healing Module
    System can detect and fix its own issues
]]

-- Self-Healing module
AntiExploit.SelfHealing = {
    detected_issues = {},
    applied_fixes = {},
    system_diagnostics = {},
    compatibility_patches = {},
    learning_from_errors = true
}

-- Run system diagnostics
function AntiExploit:RunSystemDiagnostics()
    print("[Self-Healing] Running system diagnostics...")
    
    local issues_found = {}
    
    -- Detect hook conflicts
    local hook_conflicts = self:DetectHookConflicts()
    if #hook_conflicts > 0 then
        table.insert(issues_found, {
            type = "HOOK_CONFLICT",
            severity = "HIGH",
            conflicts = hook_conflicts
        })
    end
    
    -- Detect broken functions
    local broken_functions = self:DetectBrokenFunctions()
    if #broken_functions > 0 then
        table.insert(issues_found, {
            type = "BROKEN_FUNCTIONS",
            severity = "CRITICAL",
            functions = broken_functions
        })
    end
    
    -- Detect NPC/Player confusion
    local npc_issues = self:DetectNPCIssues()
    if npc_issues then
        table.insert(issues_found, {
            type = "NPC_PLAYER_CONFUSION",
            severity = "MEDIUM",
            details = npc_issues
        })
    end
    
    -- Detect performance issues
    local perf_issues = self:DetectPerformanceIssues()
    if perf_issues then
        table.insert(issues_found, {
            type = "PERFORMANCE_DEGRADATION",
            severity = "LOW",
            metrics = perf_issues
        })
    end
    
    self.SelfHealing.detected_issues = issues_found
    
    -- Auto-fix
    if #issues_found > 0 then
        print("[Self-Healing] Found " .. #issues_found .. " issues. Attempting auto-fix...")
        self:AttemptAutoFix(issues_found)
    else
        print("[Self-Healing] No issues detected!")
    end
end

-- Attempt auto-fix
function AntiExploit:AttemptAutoFix(issues)
    for _, issue in ipairs(issues) do
        if issue.type == "HOOK_CONFLICT" then
            self:FixHookConflicts(issue.conflicts)
        elseif issue.type == "BROKEN_FUNCTIONS" then
            self:FixBrokenFunctions(issue.functions)
        elseif issue.type == "NPC_PLAYER_CONFUSION" then
            self:FixNPCConfusion(issue.details)
        elseif issue.type == "PERFORMANCE_DEGRADATION" then
            self:FixPerformanceIssues(issue.metrics)
        end
    end
end

-- Detect hook conflicts
function AntiExploit:DetectHookConflicts()
    local conflicts = {}
    local our_hooks = {}
    
    -- Collect our hooks
    local hook_table = hook.GetTable()
    for event, hooks in pairs(hook_table) do
        for name, func in pairs(hooks) do
            if string.find(name, "AntiExploit") then
                our_hooks[event] = our_hooks[event] or {}
                table.insert(our_hooks[event], name)
            end
        end
    end
    
    -- Check for conflicts
    for event, our_hook_list in pairs(our_hooks) do
        for name, _ in pairs(hook_table[event] or {}) do
            if not string.find(name, "AntiExploit") then
                -- Check critical hooks
                if string.find(name, "spectate") or 
                   string.find(name, "FAdmin") or
                   string.find(name, "pCasino") then
                    table.insert(conflicts, {
                        event = event,
                        our_hook = our_hook_list[1],
                        conflicting_hook = name,
                        addon = self:IdentifyAddonFromHook(name)
                    })
                end
            end
        end
    end
    
    return conflicts
end

-- Fix hook conflicts
function AntiExploit:FixHookConflicts(conflicts)
    for _, conflict in ipairs(conflicts) do
        print("[Self-Healing] Fixing hook conflict: " .. conflict.conflicting_hook)
        
        -- Create dynamic whitelist
        if not self.DynamicWhitelist then
            self.DynamicWhitelist = {hooks = {}, networks = {}}
        end
        
        self.DynamicWhitelist.hooks[conflict.conflicting_hook] = true
        
        -- Patch hook system
        self:PatchHookSystem(conflict)
        
        -- Record fix
        table.insert(self.SelfHealing.applied_fixes, {
            type = "HOOK_WHITELIST",
            target = conflict.conflicting_hook,
            timestamp = os.time()
        })
    end
end

-- Patch hook system
function AntiExploit:PatchHookSystem(conflict)
    -- Get reference to self
    local antiexploit_self = self
    
    -- Update hook.Add
    local original_hook_add = hook.Add
    
    hook.Add = function(event, identifier, func)
        -- Dynamic whitelist check
        if antiexploit_self.DynamicWhitelist and antiexploit_self.DynamicWhitelist.hooks[identifier] then
            return original_hook_add(event, identifier, func)
        end
        
        -- Learned safe patterns
        if antiexploit_self:IsLearnedSafeHook(identifier) then
            return original_hook_add(event, identifier, func)
        end
        
        -- Normal security check continues...
        local info = debug.getinfo(2, "S")
        if table.HasValue({"Think", "PlayerSay", "PlayerInitialSpawn"}, event) then
            if info and info.source == "@" then
                -- Analyze addon
                local addon_name = antiexploit_self:IdentifyAddonFromSource(info.source)
                if addon_name and antiexploit_self:IsAddonSafe(addon_name) then
                    -- Safe addon, learn and allow
                    antiexploit_self:LearnSafePattern("hook", identifier, addon_name)
                    return original_hook_add(event, identifier, func)
                end
                
                print("[Memory Shield] Blocked suspicious hook: " .. event)
                return false
            end
        end
        
        return original_hook_add(event, identifier, func)
    end
end

-- Detect broken functions
function AntiExploit:DetectBrokenFunctions()
    local broken = {}
    
    -- Critical functions to test
    local critical_functions = {
        {name = "FAdmin_SpectatePly", test = function()
            return type(FAdmin_SpectatePly) == "function"
        end},
        {name = "pCasino.NPCThink", test = function()
            return pCasino and type(pCasino.NPCThink) == "function"
        end},
        {name = "gmod_hands.GetOwner", test = function()
            -- Check if gmod_hands entities have GetOwner
            local hands_ent = ents.FindByClass("gmod_hands")[1]
            if IsValid(hands_ent) then
                return hands_ent.GetOwner ~= nil
            end
            return true -- No hands entities, no problem
        end}
    }
    
    for _, func_test in ipairs(critical_functions) do
        local success, result = pcall(func_test.test)
        if not success or not result then
            table.insert(broken, func_test.name)
        end
    end
    
    return broken
end

-- Fix broken functions
function AntiExploit:FixBrokenFunctions(functions)
    print("[Self-Healing] Fixing broken functions...")
    
    for _, func_name in ipairs(functions) do
        print("[Self-Healing] Function " .. func_name .. " is broken, creating stub...")
        
        -- Create stub functions for missing critical functions
        if func_name == "FAdmin_SpectatePly" and not FAdmin_SpectatePly then
            _G.FAdmin_SpectatePly = function() 
                print("[Self-Healing] FAdmin_SpectatePly stub called")
            end
        elseif func_name == "pCasino.NPCThink" then
            if not pCasino then
                _G.pCasino = {}
            end
            if not pCasino.NPCThink then
                pCasino.NPCThink = function()
                    print("[Self-Healing] pCasino.NPCThink stub called")
                end
            end
        elseif func_name == "gmod_hands.GetOwner" then
            -- Fix all gmod_hands entities
            print("[Self-Healing] Fixing gmod_hands GetOwner method...")
            
            -- Fix the entity class
            local HANDS = scripted_ents.Get("gmod_hands")
            if HANDS then
                if not HANDS.GetOwner then
                    HANDS.GetOwner = function(self)
                        if self.Owner and IsValid(self.Owner) then
                            return self.Owner
                        end
                        local parent = self:GetParent()
                        if IsValid(parent) and parent:IsPlayer() then
                            return parent
                        end
                        return NULL
                    end
                end
                scripted_ents.Register(HANDS, "gmod_hands")
            end
            
            -- Fix existing entities
            for _, hands in ipairs(ents.FindByClass("gmod_hands")) do
                if IsValid(hands) and not hands.GetOwner then
                    hands.GetOwner = function(self)
                        if self.Owner and IsValid(self.Owner) then
                            return self.Owner
                        end
                        return NULL
                    end
                end
            end
        end
    end
    
    print("[Self-Healing] Function stubs created")
end

-- Detect NPC issues
function AntiExploit:DetectNPCIssues()
    local issues = {}
    
    -- Check if NPCs are being incorrectly analyzed
    for _, ent in ipairs(ents.GetAll()) do
        if ent:IsNPC() or ent:IsNextBot() then
            local steamid = ent:EntIndex() .. "_NPC"
            if self.PlayerData and self.PlayerData[steamid] then
                table.insert(issues, {
                    entity = ent,
                    wrongly_tracked = true
                })
            end
        end
    end
    
    return #issues > 0 and issues or nil
end

-- Fix NPC confusion
function AntiExploit:FixNPCConfusion(details)
    print("[Self-Healing] Fixing NPC/Player confusion...")
    
    -- Save original function
    if not self.Original_AnalyzePlayerBehavior then
        self.Original_AnalyzePlayerBehavior = self.AnalyzePlayerBehavior
    end
    
    -- Override function
    self.AnalyzePlayerBehavior = function(this_self, ply)
        -- Add NPC check
        if not IsValid(ply) or ply:IsNPC() or ply:IsNextBot() then
            return -- Don't analyze NPCs
        end
        
        -- Call original function
        if this_self.Original_AnalyzePlayerBehavior then
            return this_self:Original_AnalyzePlayerBehavior(ply)
        end
    end
    
    -- Clean existing NPC data
    if details then
        for _, issue in ipairs(details) do
            local steamid = issue.entity:EntIndex() .. "_NPC"
            if self.PlayerData and self.PlayerData[steamid] then
                self.PlayerData[steamid] = nil
            end
        end
    end
    
    print("[Self-Healing] NPC confusion fixed!")
end

-- Detect performance issues
function AntiExploit:DetectPerformanceIssues()
    local fps = 1 / engine.TickInterval()
    local memory = collectgarbage("count")
    
    if fps < 20 or memory > 600000 then
        return {
            fps = fps,
            memory = memory,
            low_fps = fps < 20,
            high_memory = memory > 600000
        }
    end
    
    return nil
end

-- Fix performance issues
function AntiExploit:FixPerformanceIssues(metrics)
    print("[Self-Healing] Fixing performance issues...")
    
    -- Reduce monitoring frequency
    if timer.Exists("AntiExploit_PlayerMonitoring") then
        timer.Adjust("AntiExploit_PlayerMonitoring", 3)
    end
    
    -- Clean up memory
    collectgarbage("collect")
    
    -- Reduce neural network complexity temporarily
    if self.AIBrain and self.AIBrain.neural_network and self.AIBrain.neural_network.learning_rate and self.AIBrain.neural_network.learning_rate > 0.005 then
        self.AIBrain.neural_network.learning_rate = 0.005
    end
    
    print("[Self-Healing] Performance optimizations applied")
end

-- Initialize self-healing
function AntiExploit:InitializeSelfHealing()
    print("[Self-Healing] Initializing self-healing system...")
    
    -- Get reference to self
    local antiexploit_self = self
    
    -- Error handling wrapper
    local original_pcall = pcall
    _G.pcall = function(func, ...)
        local success, result = original_pcall(func, ...)
        if not success and antiexploit_self.LogError then
            antiexploit_self:LogError(result, {function_called = tostring(func)})
        end
        return success, result
    end
    
    -- Start diagnostics
    timer.Simple(10, function()
        if AntiExploit and AntiExploit.RunSystemDiagnostics then
            AntiExploit:RunSystemDiagnostics()
        end
    end)
    
    -- Enable continuous improvement
    self:EnableSelfImprovement()
    
    print("[Self-Healing] ✅ System ready to self-heal!")
end

-- Enable self improvement
function AntiExploit:EnableSelfImprovement()
    -- Continuous improvement loop
    timer.Create("AntiExploit_SelfImprovement", 60, 0, function()
        if not AntiExploit then return end
        
        -- Check system health
        local health = AntiExploit:CalculateSystemHealth()
        
        if health < 0.8 then -- Below 80%
            -- Run diagnostics
            AntiExploit:RunSystemDiagnostics()
            
            -- Learn from errors
            AntiExploit:LearnFromSystemErrors()
            
            -- Dynamic optimization
            AntiExploit:OptimizeBasedOnErrors()
        end
    end)
end

-- Calculate system health
function AntiExploit:CalculateSystemHealth()
    local health_score = 1.0
    
    -- False positive rate
    if self.PerformanceMetrics then
        health_score = health_score - (self.PerformanceMetrics.false_positive_rate or 0)
    end
    
    -- Error count
    local recent_errors = 0
    if self.ErrorLog then
        local current_time = os.time()
        for _, error in ipairs(self.ErrorLog) do
            if error.timestamp > (current_time - 3600) then
                recent_errors = recent_errors + 1
            end
        end
    end
    health_score = health_score - (recent_errors * 0.05)
    
    -- Hook conflicts
    local conflicts = #self:DetectHookConflicts()
    health_score = health_score - (conflicts * 0.1)
    
    return math.max(0, health_score)
end

-- Learn from system errors
function AntiExploit:LearnFromSystemErrors()
    -- Analyze error patterns
    local error_patterns = {}
    
    -- Collect recent errors
    if self.ErrorLog then
        for _, error_entry in ipairs(self.ErrorLog) do
            local pattern = self:ExtractErrorPattern(error_entry)
            error_patterns[pattern] = (error_patterns[pattern] or 0) + 1
        end
    end
    
    -- Learn from frequent errors
    for pattern, count in pairs(error_patterns) do
        if count > 3 then -- More than 3 times
            self:CreateAutomaticPatch(pattern)
        end
    end
end

-- Extract error pattern
function AntiExploit:ExtractErrorPattern(error_entry)
    local pattern = error_entry.message or ""
    -- Simplify pattern for matching
    pattern = string.gsub(pattern, "%d+", "N")
    pattern = string.gsub(pattern, "0x%x+", "ADDR")
    return pattern
end

-- Create automatic patch
function AntiExploit:CreateAutomaticPatch(error_pattern)
    -- Get reference to self
    local antiexploit_self = self
    
    -- Patch strategies based on error pattern
    local patch_strategies = {
        ["attempt to index nil value"] = function(context)
            print("[Self-Healing] Creating nil check patch")
        end,
        ["attempt to call nil value"] = function(context)
            print("[Self-Healing] Creating function existence patch")
        end,
        ["hook conflict"] = function(context)
            -- Add to hook whitelist
            if antiexploit_self.DynamicWhitelist then
                antiexploit_self.DynamicWhitelist.hooks[context.hook_name] = true
            end
        end
    }
    
    for pattern, strategy in pairs(patch_strategies) do
        if string.find(error_pattern, pattern) then
            strategy({
                variable = "target",
                func = "target_func",
                hook_name = "conflicting_hook"
            })
        end
    end
end

-- Optimize based on errors
function AntiExploit:OptimizeBasedOnErrors()
    -- Simple optimizations
    if self.ErrorLog and #self.ErrorLog > 50 then
        -- Too many errors, be more conservative
        AntiExploit.Config.AUTO_WARN_THRESHOLD = math.min(0.85, AntiExploit.Config.AUTO_WARN_THRESHOLD + 0.05)
        self.ErrorLog = {} -- Reset
    end
end

-- Log error
function AntiExploit:LogError(error_msg, context)
    if not self.ErrorLog then
        self.ErrorLog = {}
    end
    
    table.insert(self.ErrorLog, {
        message = error_msg or "Unknown error",
        context = context or {},
        timestamp = os.time(),
        stack_trace = debug.traceback()
    })
    
    -- Learn immediately
    if self.SelfHealing and self.SelfHealing.learning_from_errors then
        self:LearnFromError(error_msg, context)
    end
end

-- Learn from error
function AntiExploit:LearnFromError(error_msg, context)
    -- Simple learning from common errors
    if error_msg and string.find(error_msg, "nil") then
        -- Increase nil checks in future
        if self.AIBrain and self.AIBrain.neural_network and self.AIBrain.neural_network.weights then
            -- Safely access nested structure
            local weights = self.AIBrain.neural_network.weights
            if weights[1] and weights[1][1] and weights[1][1][1] then
                weights[1][1][1] = (weights[1][1][1] or 0) * 0.95
            end
        end
    end
end

-- Add to main initialization
local original_init = AntiExploit.InitializeAutonomousSystem
AntiExploit.InitializeAutonomousSystem = function(self)
    -- Initialize self-healing first
    self:InitializeSelfHealing()
    
    -- Normal init
    if original_init then
        original_init(self)
    end
end

print("[Self-Healing AI] Module loaded - System can now fix itself!")