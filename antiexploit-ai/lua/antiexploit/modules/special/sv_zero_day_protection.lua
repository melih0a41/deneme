--[[
    Zero-Day Protection Module
    Detects unknown exploits through behavioral analysis
]]

AntiExploit.ZeroDay = {
    -- Anomaly detection thresholds
    anomaly_scores = {},
    baseline_behaviors = {},
    suspicious_patterns = {},
    unknown_detections = 0
}

-- Initialize Zero-Day Protection
function AntiExploit:InitializeZeroDayProtection()
    print("[Zero-Day Protection] Initializing unknown exploit detection...")
    
    -- Start anomaly detection
    timer.Create("AntiExploit_AnomalyDetection", 2, 0, function()
        self:PerformAnomalyDetection()
    end)
    
    -- Baseline learning timer
    timer.Create("AntiExploit_BaselineLearning", 30, 0, function()
        self:UpdateBehaviorBaseline()
    end)
    
    print("[Zero-Day Protection] ✅ Active - Learning normal behavior patterns")
end

-- Anomaly Detection Engine
function AntiExploit:PerformAnomalyDetection()
    for _, ply in ipairs(player.GetAll()) do
        if IsValid(ply) and not ply:IsBot() then
            local anomaly_score = self:CalculateAnomalyScore(ply)
            
            -- Store score
            local steamid = ply:SteamID64()
            if not self.ZeroDay.anomaly_scores[steamid] then
                self.ZeroDay.anomaly_scores[steamid] = {}
            end
            
            table.insert(self.ZeroDay.anomaly_scores[steamid], {
                score = anomaly_score,
                timestamp = CurTime()
            })
            
            -- Keep only recent scores
            if #self.ZeroDay.anomaly_scores[steamid] > 50 then
                table.remove(self.ZeroDay.anomaly_scores[steamid], 1)
            end
            
            -- Check for anomaly spike
            if anomaly_score > 0.7 then
                self:InvestigateAnomaly(ply, anomaly_score)
            end
        end
    end
end

-- Calculate anomaly score for player
function AntiExploit:CalculateAnomalyScore(ply)
    local score = 0
    local factors = {}
    
    -- 1. Network Traffic Anomaly
    local network_anomaly = self:AnalyzeNetworkTrafficAnomaly(ply)
    score = score + network_anomaly * 0.3
    if network_anomaly > 0.5 then
        table.insert(factors, "NETWORK_ANOMALY")
    end
    
    -- 2. Command Frequency Anomaly
    local command_anomaly = self:AnalyzeCommandAnomaly(ply)
    score = score + command_anomaly * 0.2
    if command_anomaly > 0.5 then
        table.insert(factors, "COMMAND_ANOMALY")
    end
    
    -- 3. Movement Pattern Anomaly
    local movement_anomaly = self:AnalyzeMovementAnomaly(ply)
    score = score + movement_anomaly * 0.2
    if movement_anomaly > 0.5 then
        table.insert(factors, "MOVEMENT_ANOMALY")
    end
    
    -- 4. Resource Usage Anomaly
    local resource_anomaly = self:AnalyzeResourceAnomaly(ply)
    score = score + resource_anomaly * 0.15
    if resource_anomaly > 0.5 then
        table.insert(factors, "RESOURCE_ANOMALY")
    end
    
    -- 5. Interaction Pattern Anomaly
    local interaction_anomaly = self:AnalyzeInteractionAnomaly(ply)
    score = score + interaction_anomaly * 0.15
    if interaction_anomaly > 0.5 then
        table.insert(factors, "INTERACTION_ANOMALY")
    end
    
    -- Store factors for analysis
    if #factors > 0 then
        local steamid = ply:SteamID64()
        self.ZeroDay.suspicious_patterns[steamid] = factors
    end
    
    return math.min(1, score)
end

-- Analyze network traffic patterns
function AntiExploit:AnalyzeNetworkTrafficAnomaly(ply)
    local steamid = ply:SteamID64()
    local player_data = self.PlayerData[steamid]
    
    if not player_data or not player_data.network_activity then
        return 0
    end
    
    -- Count recent network messages
    local recent_count = 0
    local unique_messages = {}
    local current_time = CurTime()
    
    for _, activity in ipairs(player_data.network_activity) do
        if current_time - activity.time < 10 then
            recent_count = recent_count + 1
            unique_messages[activity.message] = (unique_messages[activity.message] or 0) + 1
        end
    end
    
    -- Anomaly indicators
    local anomaly = 0
    
    -- Too many messages
    if recent_count > 50 then
        anomaly = anomaly + 0.4
    end
    
    -- Too many unique message types (scanning for vulnerabilities)
    if table.Count(unique_messages) > 20 then
        anomaly = anomaly + 0.3
    end
    
    -- Repetitive patterns (automated exploit)
    for msg, count in pairs(unique_messages) do
        if count > 10 then
            anomaly = anomaly + 0.3
            break
        end
    end
    
    return math.min(1, anomaly)
end

-- Analyze command execution patterns
function AntiExploit:AnalyzeCommandAnomaly(ply)
    local steamid = ply:SteamID64()
    local player_data = self.PlayerData[steamid]
    
    if not player_data or not player_data.commands then
        return 0
    end
    
    -- Analyze command patterns
    local recent_commands = {}
    local current_time = CurTime()
    
    for _, cmd in ipairs(player_data.commands) do
        if cmd.timestamp and current_time - cmd.timestamp < 5 then
            table.insert(recent_commands, cmd)
        end
    end
    
    -- Check for anomalies
    local anomaly = 0
    
    -- Rapid command execution
    if #recent_commands > 15 then
        anomaly = anomaly + 0.5
    end
    
    -- Check for command patterns that suggest scanning
    local command_types = {}
    for _, cmd in ipairs(recent_commands) do
        local cmd_type = string.match(cmd.cmd or "", "^(%w+)")
        if cmd_type then
            command_types[cmd_type] = (command_types[cmd_type] or 0) + 1
        end
    end
    
    -- Too many different command types (scanning behavior)
    if table.Count(command_types) > 10 then
        anomaly = anomaly + 0.5
    end
    
    return math.min(1, anomaly)
end

-- Analyze movement patterns
function AntiExploit:AnalyzeMovementAnomaly(ply)
    local steamid = ply:SteamID64()
    local player_data = self.PlayerData[steamid]
    
    if not player_data or not player_data.movements then
        return 0
    end
    
    local anomaly = 0
    
    -- Get recent movements
    local recent_movements = {}
    for i = math.max(1, #player_data.movements - 20), #player_data.movements do
        if player_data.movements[i] then
            table.insert(recent_movements, player_data.movements[i])
        end
    end
    
    if #recent_movements < 5 then return 0 end
    
    -- Check for teleportation patterns
    for i = 2, #recent_movements do
        local dist = recent_movements[i].position:Distance(recent_movements[i-1].position)
        local time_diff = recent_movements[i].timestamp - recent_movements[i-1].timestamp
        
        if time_diff > 0 then
            local speed = dist / time_diff
            
            -- Impossible speed
            if speed > 2000 then
                anomaly = anomaly + 0.3
            end
            
            -- Instant position changes (teleport)
            if dist > 500 and time_diff < 0.1 then
                anomaly = anomaly + 0.4
            end
        end
    end
    
    -- Check for noclip patterns (consistent Z changes without ground)
    local z_changes = 0
    for i = 2, #recent_movements do
        local z_diff = math.abs(recent_movements[i].position.z - recent_movements[i-1].position.z)
        if z_diff > 50 then
            z_changes = z_changes + 1
        end
    end
    
    if z_changes > 5 then
        anomaly = anomaly + 0.3
    end
    
    return math.min(1, anomaly)
end

-- Analyze resource usage
function AntiExploit:AnalyzeResourceAnomaly(ply)
    local anomaly = 0
    
    -- Check prop spawn rate
    local props = 0
    for _, ent in ipairs(ents.GetAll()) do
        if IsValid(ent) and ent.CPPIGetOwner and ent:CPPIGetOwner() == ply then
            local class = ent:GetClass()
            if string.find(class, "prop_") then
                props = props + 1
            end
        end
    end
    
    -- Too many props
    if props > 100 then
        anomaly = anomaly + 0.5
    end
    
    -- Check for rapid entity creation
    local recent_ents = ents.FindInSphere(ply:GetPos(), 1000)
    local owned_recent = 0
    
    for _, ent in ipairs(recent_ents) do
        if IsValid(ent) and ent.CPPIGetOwner and ent:CPPIGetOwner() == ply then
            if ent.GetCreationTime and (CurTime() - ent:GetCreationTime()) < 10 then
                owned_recent = owned_recent + 1
            end
        end
    end
    
    if owned_recent > 20 then
        anomaly = anomaly + 0.5
    end
    
    return math.min(1, anomaly)
end

-- Analyze interaction patterns - DÜZELTILMIŞ
function AntiExploit:AnalyzeInteractionAnomaly(ply)
    local anomaly = 0
    
    -- Check weapon switching frequency
    if ply.LastWeaponSwitch and type(ply.LastWeaponSwitch) == "table" then
        local switches = 0
        for i = #ply.LastWeaponSwitch, math.max(1, #ply.LastWeaponSwitch - 10), -1 do
            if ply.LastWeaponSwitch[i] and (CurTime() - ply.LastWeaponSwitch[i]) < 5 then
                switches = switches + 1
            end
        end
        
        if switches > 8 then
            anomaly = anomaly + 0.5
        end
    end
    
    -- Check use spam
    if ply.LastUseTime and type(ply.LastUseTime) == "table" then
        local uses = 0
        for _, use_time in ipairs(ply.LastUseTime) do
            if use_time and (CurTime() - use_time) < 2 then
                uses = uses + 1
            end
        end
        
        if uses > 10 then
            anomaly = anomaly + 0.5
        end
    end
    
    return math.min(1, anomaly)
end

-- Investigate detected anomaly
function AntiExploit:InvestigateAnomaly(ply, anomaly_score)
    print(string.format("[Zero-Day] Anomaly detected for %s (Score: %.2f)", 
        ply:Nick(), anomaly_score))
    
    local steamid = ply:SteamID64()
    
    -- Deep analysis
    local investigation = {
        player = ply,
        score = anomaly_score,
        factors = self.ZeroDay.suspicious_patterns[steamid] or {},
        timestamp = CurTime()
    }
    
    -- Check if this is a new pattern
    local is_new_pattern = self:IsNewExploitPattern(investigation)
    
    if is_new_pattern then
        self.ZeroDay.unknown_detections = self.ZeroDay.unknown_detections + 1
        
        -- Create threat assessment
        local threat_data = {
            player = ply,
            confidence = anomaly_score,
            indicators = investigation.factors,
            is_threat = true,
            threat_type = "UNKNOWN_EXPLOIT_PATTERN",
            pattern_id = "ZERO_DAY_" .. self.ZeroDay.unknown_detections
        }
        
        -- Learn from this pattern
        self:LearnNewThreatPattern(threat_data)
        
        -- Take action
        if anomaly_score > 0.85 then
            self:HandleAutonomousThreat("ZERO_DAY_EXPLOIT", threat_data)
        elseif anomaly_score > 0.7 then
            -- Monitor closely
            self:EnhancedMonitoring(ply)
        end
    end
end

-- Check if this is a new exploit pattern
function AntiExploit:IsNewExploitPattern(investigation)
    -- Compare against known patterns
    local pattern_hash = self:HashPattern(investigation.factors)
    
    -- Check if we've seen this before
    if self.AIBrain.pattern_memory["zero_day"] then
        for _, memory in ipairs(self.AIBrain.pattern_memory["zero_day"]) do
            if memory.data.hash == pattern_hash then
                return false -- Known pattern
            end
        end
    end
    
    return true -- New pattern
end

-- Create hash from pattern factors
function AntiExploit:HashPattern(factors)
    table.sort(factors)
    return util.CRC(table.concat(factors, "|"))
end

-- Learn new threat pattern
function AntiExploit:LearnNewThreatPattern(threat_data)
    print("[Zero-Day] Learning new threat pattern: " .. threat_data.pattern_id)
    
    -- Add to pattern memory
    self:UpdatePatternMemory("zero_day", {
        hash = self:HashPattern(threat_data.indicators),
        indicators = threat_data.indicators,
        confidence = threat_data.confidence,
        first_seen = CurTime(),
        detection_count = 1
    })
    
    -- Train neural network
    local features = self:ExtractAnomalyFeatures(threat_data)
    self:TrainNeuralNetwork(features, 3) -- Class 3 = Confirmed threat
    
    -- Create signature for future detection
    self:GenerateSignatureFromAnomaly(threat_data)
end

-- Generate signature from anomaly
function AntiExploit:GenerateSignatureFromAnomaly(threat_data)
    -- Create a unique signature
    local signature = "AUTOLEARN_" .. threat_data.pattern_id
    
    -- Add to threat database
    if not table.HasValue(self.ThreatDatabase.network_signatures, signature) then
        table.insert(self.ThreatDatabase.network_signatures, signature)
        
        -- Also add to custom signatures for persistence
        if not self.ThreatDatabase.custom_signatures then
            self.ThreatDatabase.custom_signatures = {}
        end
        
        table.insert(self.ThreatDatabase.custom_signatures, {
            signature = signature,
            pattern = threat_data.indicators,
            learned_at = os.time(),
            confidence = threat_data.confidence
        })
    end
end

-- Extract features from anomaly
function AntiExploit:ExtractAnomalyFeatures(threat_data)
    local features = {}
    
    -- Initialize features
    for i = 1, 20 do
        features[i] = 0
    end
    
    -- Encode indicators
    local indicator_map = {
        ["NETWORK_ANOMALY"] = 1,
        ["COMMAND_ANOMALY"] = 2,
        ["MOVEMENT_ANOMALY"] = 3,
        ["RESOURCE_ANOMALY"] = 4,
        ["INTERACTION_ANOMALY"] = 5
    }
    
    for _, indicator in ipairs(threat_data.indicators) do
        local idx = indicator_map[indicator]
        if idx then
            features[idx] = 1
        end
    end
    
    -- Add confidence
    features[6] = threat_data.confidence
    
    -- Add time-based features
    features[7] = math.sin(CurTime() / 3600) -- Hour pattern
    features[8] = math.sin(CurTime() / 86400) -- Day pattern
    
    return features
end

-- Enhanced monitoring for suspicious players
function AntiExploit:EnhancedMonitoring(ply)
    local steamid = ply:SteamID64()
    
    print("[Zero-Day] Enhanced monitoring activated for: " .. ply:Nick())
    
    -- Create detailed monitoring
    timer.Create("AntiExploit_Enhanced_" .. steamid, 0.5, 120, function()
        if not IsValid(ply) then
            timer.Remove("AntiExploit_Enhanced_" .. steamid)
            return
        end
        
        -- Log everything
        local detailed_log = {
            position = ply:GetPos(),
            angles = ply:GetAngles(),
            velocity = ply:GetVelocity(),
            weapons = {},
            active_weapon = IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() or "none",
            health = ply:Health(),
            armor = ply:Armor()
        }
        
        -- Store for analysis
        if not self.EnhancedMonitoringData then
            self.EnhancedMonitoringData = {}
        end
        
        if not self.EnhancedMonitoringData[steamid] then
            self.EnhancedMonitoringData[steamid] = {}
        end
        
        table.insert(self.EnhancedMonitoringData[steamid], detailed_log)
        
        -- Analyze for patterns
        if #self.EnhancedMonitoringData[steamid] > 50 then
            self:AnalyzeEnhancedMonitoringData(ply)
            self.EnhancedMonitoringData[steamid] = {} -- Reset
        end
    end)
end

-- Analyze enhanced monitoring data
function AntiExploit:AnalyzeEnhancedMonitoringData(ply)
    -- Implementation for analyzing detailed monitoring data
    print("[Zero-Day] Analyzing enhanced monitoring data for: " .. ply:Nick())
end

-- Update behavior baseline
function AntiExploit:UpdateBehaviorBaseline()
    -- Calculate normal behavior patterns
    local baselines = {
        avg_network_messages = 0,
        avg_commands = 0,
        avg_movement_speed = 0,
        avg_props = 0
    }
    
    local player_count = 0
    
    for _, ply in ipairs(player.GetAll()) do
        if IsValid(ply) and not ply:IsBot() and ply:Team() ~= TEAM_SPECTATOR then
            player_count = player_count + 1
            
            -- Calculate averages
            -- (Implementation would calculate actual averages)
        end
    end
    
    if player_count > 0 then
        self.ZeroDay.baseline_behaviors = baselines
    end
end

-- Heuristic analysis for unknown patterns
function AntiExploit:HeuristicAnalysis(ply)
    local heuristic_score = 0
    local reasons = {}
    
    -- Heuristic 1: Entropy in actions
    local action_entropy = self:CalculateActionEntropy(ply)
    if action_entropy > 0.8 then
        heuristic_score = heuristic_score + 0.3
        table.insert(reasons, "HIGH_ACTION_ENTROPY")
    end
    
    -- Heuristic 2: Timing patterns
    local timing_anomaly = self:AnalyzeTimingPatterns(ply)
    if timing_anomaly > 0.7 then
        heuristic_score = heuristic_score + 0.3
        table.insert(reasons, "TIMING_ANOMALY")
    end
    
    -- Heuristic 3: Statistical outliers
    local outlier_score = self:CalculateOutlierScore(ply)
    if outlier_score > 0.8 then
        heuristic_score = heuristic_score + 0.4
        table.insert(reasons, "STATISTICAL_OUTLIER")
    end
    
    return heuristic_score, reasons
end

-- Helper functions
function AntiExploit:CalculateActionEntropy(ply)
    -- Placeholder for entropy calculation
    return 0
end

function AntiExploit:AnalyzeTimingPatterns(ply)
    -- Placeholder for timing analysis
    return 0
end

function AntiExploit:CalculateOutlierScore(ply)
    -- Placeholder for outlier calculation
    return 0
end

-- Initialize on startup
hook.Add("Initialize", "AntiExploit_ZeroDay_Init", function()
    timer.Simple(5, function()
        if AntiExploit then
            AntiExploit:InitializeZeroDayProtection()
        end
    end)
end)

print("[Zero-Day Protection] Module loaded - Unknown exploit detection active")