--[[
    Network Analysis Module
    Analyzes network messages for threats
]]

function AntiExploit:AnalyzeNetworkMessage(messageName, caller_info)
    local threat_assessment = {
        is_threat = false,
        confidence = 0,
        indicators = {}
    }
    
    if not messageName then
        threat_assessment.is_threat = true
        threat_assessment.confidence = 1.0
        table.insert(threat_assessment.indicators, "NULL_MESSAGE_NAME")
        return threat_assessment
    end
    
    -- SAM admin whitelist
    if messageName and (string.find(messageName, "sam_") or string.find(messageName, "SAM_")) then
        return {is_threat = false, confidence = 0, indicators = {"WHITELISTED_SAM"}}
    end
    
    -- Check against known malicious networks
    for _, signature in ipairs(self.ThreatDatabase.network_signatures) do
        if string.find(messageName:lower(), signature:lower()) then
            threat_assessment.confidence = threat_assessment.confidence + 0.9
            table.insert(threat_assessment.indicators, "MALICIOUS_SIGNATURE:" .. signature)
        end
    end
    
    -- Analyze message characteristics
    local message_analysis = self:AnalyzeMessageCharacteristics(messageName)
    threat_assessment.confidence = threat_assessment.confidence + message_analysis.suspicion_score
    
    if message_analysis.suspicious_patterns then
        for _, pattern in ipairs(message_analysis.suspicious_patterns) do
            table.insert(threat_assessment.indicators, pattern)
        end
    end
    
    -- AI analysis
    local net_features = self:ExtractNetworkFeatures(messageName, caller_info)
    local ai_class, ai_confidence = self:AIPredict(net_features)
    
    -- Combine scores
    threat_assessment.confidence = math.min(1.0, threat_assessment.confidence + (ai_confidence * 0.4))
    threat_assessment.is_threat = threat_assessment.confidence > AntiExploit.Config.AUTO_WARN_THRESHOLD
    
    return threat_assessment
end

function AntiExploit:AnalyzeMessageCharacteristics(messageName)
    local analysis = {
        suspicion_score = 0,
        suspicious_patterns = {}
    }
    
    -- Length analysis
    local name_length = string.len(messageName)
    if name_length > 50 then
        analysis.suspicion_score = analysis.suspicion_score + 0.3
        table.insert(analysis.suspicious_patterns, "LONG_MESSAGE_NAME")
    end
    
    -- Character analysis
    local non_alphanumeric = string.gsub(messageName, "[%w_]", "")
    if string.len(non_alphanumeric) > name_length * 0.3 then
        analysis.suspicion_score = analysis.suspicion_score + 0.4
        table.insert(analysis.suspicious_patterns, "NON_ALPHANUMERIC_CHARS")
    end
    
    -- Pattern analysis
    if string.match(messageName, "^[0-9A-Fa-f]+$") and name_length > 10 then
        analysis.suspicion_score = analysis.suspicion_score + 0.5
        table.insert(analysis.suspicious_patterns, "HEX_PATTERN")
    end
    
    if string.match(messageName, "^[A-Za-z0-9+/]+=*$") and name_length > 8 then
        analysis.suspicion_score = analysis.suspicion_score + 0.6
        table.insert(analysis.suspicious_patterns, "BASE64_PATTERN")
    end
    
    return analysis
end

function AntiExploit:ExtractNetworkFeatures(messageName, caller_info)
    local features = {}
    
    -- Initialize features
    for i = 1, 20 do
        features[i] = 0
    end
    
    if messageName then
        -- Message name analysis
        features[1] = math.min(1, string.len(messageName) / 50)
        features[2] = self:CalculateStringEntropy(messageName)
        
        -- Character analysis
        local alphanumeric = string.gsub(messageName, "[^%w_]", "")
        features[3] = 1 - (string.len(alphanumeric) / math.max(1, string.len(messageName)))
        
        -- Pattern matching
        features[4] = string.match(messageName, "^[0-9A-Fa-f]+$") and 1 or 0
        features[5] = string.match(messageName, "^[A-Za-z0-9+/]+=*$") and 1 or 0
        
        -- Known exploit signatures
        for i, signature in ipairs(self.ThreatDatabase.network_signatures) do
            if string.find(messageName:lower(), signature:lower()) then
                features[6] = 1
                features[7] = i / #self.ThreatDatabase.network_signatures
                break
            end
        end
        
        -- Case analysis
        local upper_count = self:CountPattern(messageName, "[A-Z]")
        local lower_count = self:CountPattern(messageName, "[a-z]")
        features[8] = upper_count / math.max(1, upper_count + lower_count)
    end
    
    -- Caller analysis
    if caller_info then
        features[9] = caller_info.source == "@" and 1 or 0
    end
    
    return features
end