--[[
    Code Analysis Module
    Analyzes code execution and compilation
]]

function AntiExploit:AnalyzeCodeExecution(code, caller_info)
    if not code then return {is_threat = false, confidence = 0} end
    
    local threat_score = 0
    local threat_indicators = {}
    
    -- Check against known threats
    for _, pattern in ipairs(self.ThreatDatabase.workshop_threats) do
        if string.find(code:lower(), pattern:lower()) then
            threat_score = threat_score + 0.15
            table.insert(threat_indicators, "THREAT_PATTERN:" .. pattern)
        end
    end
    
    -- Analyze code complexity and obfuscation
    local complexity_score = self:AnalyzeCodeComplexity(code)
    local obfuscation_score = self:AnalyzeObfuscation(code)
    
    threat_score = threat_score + (complexity_score * 0.2) + (obfuscation_score * 0.3)
    
    -- AI Analysis
    local ai_features = self:ExtractCodeFeatures(code, caller_info)
    local ai_class, ai_confidence = self:AIPredict(ai_features)
    
    -- Combine scores
    local combined_confidence = (threat_score * 0.7) + (ai_confidence * 0.3)
    
    return {
        is_threat = combined_confidence > AntiExploit.Config.AUTO_WARN_THRESHOLD,
        confidence = combined_confidence,
        indicators = threat_indicators,
        ai_classification = ai_class,
        code = code,
        caller = caller_info,
        complexity = complexity_score,
        obfuscation = obfuscation_score
    }
end

function AntiExploit:AnalyzeCodeCompilation(code, caller_info)
    -- Code compilation analysis - similar to execution
    return self:AnalyzeCodeExecution(code, caller_info)
end

function AntiExploit:AnalyzeCodeComplexity(code)
    if not code then return 0 end
    
    local complexity = 0
    
    -- Nested brackets
    local open_brackets = self:CountPattern(code, "{")
    local close_brackets = self:CountPattern(code, "}")
    complexity = complexity + math.abs(open_brackets - close_brackets) * 0.1
    
    -- Control structures
    local if_count = self:CountPattern(code, "if%s*%(")
    local for_count = self:CountPattern(code, "for%s*%(")
    local while_count = self:CountPattern(code, "while%s*%(")
    
    complexity = complexity + (if_count + for_count + while_count) * 0.05
    
    -- Function definitions
    local func_count = self:CountPattern(code, "function")
    complexity = complexity + func_count * 0.1
    
    return math.min(1, complexity)
end

function AntiExploit:AnalyzeObfuscation(code)
    if not code then return 0 end
    
    local obfuscation_score = 0
    
    -- Character frequency analysis
    local char_freq = {}
    for i = 1, string.len(code) do
        local char = string.sub(code, i, i)
        char_freq[char] = (char_freq[char] or 0) + 1
    end
    
    -- High frequency of special characters
    local special_chars = 0
    for char, freq in pairs(char_freq) do
        if not string.match(char, "[%w%s]") then
            special_chars = special_chars + freq
        end
    end
    
    if special_chars > string.len(code) * 0.3 then
        obfuscation_score = obfuscation_score + 0.4
    end
    
    -- Long strings without spaces
    local longest_no_space = 0
    for word in string.gmatch(code, "[^%s]+") do
        if string.len(word) > longest_no_space then
            longest_no_space = string.len(word)
        end
    end
    
    if longest_no_space > 100 then
        obfuscation_score = obfuscation_score + 0.3
    end
    
    -- Entropy check
    local entropy = self:CalculateStringEntropy(code)
    if entropy > 0.8 then
        obfuscation_score = obfuscation_score + 0.3
    end
    
    return math.min(1, obfuscation_score)
end

function AntiExploit:ExtractCodeFeatures(code, caller_info)
    if not code then return {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} end
    
    local features = {}
    
    -- Basic metrics (1-5)
    features[1] = math.min(1, string.len(code) / 1000)
    features[2] = self:CountPattern(code, "[%w_]+%(") / math.max(1, string.len(code))
    features[3] = self:CountPattern(code, "string%.") / math.max(1, string.len(code))
    features[4] = self:CountPattern(code, "debug%.") / math.max(1, string.len(code))
    features[5] = self:CountPattern(code, "http") > 0 and 1 or 0
    
    -- Threat patterns (6-10)
    features[6] = self:CountPattern(code, "base64") > 0 and 1 or 0
    features[7] = self:CountPattern(code, "_G%[") > 0 and 1 or 0
    features[8] = self:CountPattern(code, "getfenv") > 0 and 1 or 0
    features[9] = self:CountPattern(code, "RunString") > 0 and 1 or 0
    features[10] = self:CountPattern(code, "BroadcastLua") > 0 and 1 or 0
    
    -- Complexity metrics (11-15)
    features[11] = self:CountPattern(code, "if") / math.max(1, string.len(code))
    features[12] = self:CountPattern(code, "for") / math.max(1, string.len(code))
    features[13] = self:CountPattern(code, "function") / math.max(1, string.len(code))
    features[14] = self:CalculateStringEntropy(code)
    features[15] = self:CountPattern(code, "net%.") > 0 and 1 or 0
    
    -- Advanced patterns (16-20)
    features[16] = self:CountPattern(code, "util%.") > 0 and 1 or 0
    features[17] = self:CountPattern(code, "hook%.") > 0 and 1 or 0
    features[18] = self:CountPattern(code, "timer%.") > 0 and 1 or 0
    features[19] = self:CountPattern(code, "file%.") > 0 and 1 or 0
    features[20] = caller_info and (caller_info.source == "@" and 1 or 0) or 0
    
    return features
end