--[[
    Neural Network Learning Module
    Handles AI training and optimization
]]

function AntiExploit:StartAutonomousLearning()
    -- Continuous learning timer
    timer.Create("AntiExploit_ContinuousLearning", 30, 0, function()
        self:PerformContinuousLearning()
    end)
    
    -- Pattern analysis timer
    timer.Create("AntiExploit_PatternAnalysis", 120, 0, function()
        self:AnalyzeNewPatterns()
    end)
    
    -- Threat intelligence update
    timer.Create("AntiExploit_ThreatIntelUpdate", 600, 0, function()
        self:UpdateThreatIntelligence()
    end)
    
    print("[Autonomous Learning] ðŸ§  Continuous learning active")
end

function AntiExploit:PerformContinuousLearning()
    -- Analyze recent events for learning opportunities
    local learning_data = self:GatherLearningData()
    
    if #learning_data > 0 then
        for _, data in ipairs(learning_data) do
            self:ProcessLearningData(data)
        end
        
        -- Auto-adjust system based on learning
        self:AutoAdjustSystem()
    end
end

function AntiExploit:GatherLearningData()
    local learning_data = {}
    
    -- Collect data from recent player activities
    if self.PlayerData then
        for steamid, player_data in pairs(self.PlayerData) do
            if player_data and player_data.movements and #player_data.movements > 5 then
                table.insert(learning_data, {
                    event_type = "PLAYER_BEHAVIOR",
                    steamid = steamid,
                    data = player_data,
                    timestamp = CurTime()
                })
            end
        end
    end
    
    return learning_data
end

function AntiExploit:ProcessLearningData(data)
   -- Extract features from the data
   local features = self:ExtractLearningFeatures(data)
   
   -- Determine correct classification
   local classification = self:AutoClassifyEvent(data)
   
   -- Train neural network if valid classification
   if classification >= 0 then
       self:TrainNeuralNetwork(features, classification)
       
       -- Update pattern memory
       self:UpdatePatternMemory(data.event_type, data)
       
       print(string.format("[Auto Learning] Processed %s event (Class: %d)", 
                          data.event_type, classification))
   end
end

function AntiExploit:TrainNeuralNetwork(features, target_class)
   -- Create target output
   local target = {0, 0, 0, 0}
   target[target_class + 1] = 1
   
   -- Backpropagation
   self:Backpropagation(features, target)
   
   -- Auto-adjust learning rate based on performance
   if AntiExploit.Config.AUTO_OPTIMIZATION then
       self:AutoAdjustLearningRate()
   end
end

function AntiExploit:AutoAdjustLearningRate()
   -- Auto-adjust learning rate based on training progress
   local samples = self.AIBrain.neural_network.training_samples or 0
   
   if samples > 1000 then
       self.AIBrain.neural_network.learning_rate = 0.005
   elseif samples > 500 then
       self.AIBrain.neural_network.learning_rate = 0.01
   end
end

function AntiExploit:ExtractLearningFeatures(data)
   local features = {}
   
   -- Basic features
   for i = 1, 20 do
       features[i] = 0
   end
   
   if data.event_type == "PLAYER_BEHAVIOR" and data.data then
       features[1] = #(data.data.movements or {}) / 50 -- Movement count
       features[2] = #(data.data.commands or {}) / 20 -- Command count  
       features[3] = #(data.data.chat_messages or {}) / 10 -- Chat count
       features[4] = math.random() * 0.1 -- Small random factor
       features[5] = data.data.behavioral_score or 0
   end
   
   return features
end

function AntiExploit:AutoClassifyEvent(data)
   -- Automatically classify events based on multiple factors
   local confidence_score = 0
   
   -- Research-based classification
   if data.research_match then
       confidence_score = confidence_score + 0.8
   end
   
   -- Behavioral classification
   if data.behavioral_anomaly then
       confidence_score = confidence_score + data.behavioral_anomaly * 0.6
   end
   
   -- Network classification
   if data.network_anomaly then
       confidence_score = confidence_score + data.network_anomaly * 0.7
   end
   
   -- Activity level classification
   if data.event_type == "PLAYER_BEHAVIOR" and data.data then
       local activity_level = 0
       
       if data.data.movements then
           activity_level = activity_level + #data.data.movements
       end
       
       if activity_level > 100 then
           confidence_score = confidence_score + 0.3
       end
   end
   
   -- Determine class based on confidence
   if confidence_score >= 0.9 then
       return 3 -- Confirmed threat
   elseif confidence_score >= 0.7 then
       return 2 -- Likely exploit
   elseif confidence_score >= 0.4 then
       return 1 -- Suspicious
   else
       return 0 -- Normal
   end
end

function AntiExploit:AutoAdjustSystem()
   -- Simple auto-adjustment based on learning progress
   if self.AIBrain and self.AIBrain.neural_network then
       local training_samples = self.AIBrain.neural_network.training_samples or 0
       
       if training_samples > 100 then
           -- Reduce learning rate for stability
           self.AIBrain.neural_network.learning_rate = math.max(0.001, self.AIBrain.neural_network.learning_rate * 0.95)
       end
   end
end

function AntiExploit:LearnFromThreat(threat_type, threat_data)
   -- Create training sample
   local features = self:ExtractFeaturesFromThreat(threat_data)
   local target_class = self:DetermineThreatClass(threat_type, threat_data.confidence)
   
   -- Train neural network
   self:TrainNeuralNetwork(features, target_class)
   
   -- Update pattern memory
   self:UpdatePatternMemory(threat_type, threat_data)
   
   -- Increment learning counter
   self.AIBrain.neural_network.training_samples = self.AIBrain.neural_network.training_samples + 1
   
   print(string.format("[Auto Learning] Learned from %s (Sample #%d)", 
                      threat_type, self.AIBrain.neural_network.training_samples))
end

function AntiExploit:LearnFromSafeCode(code, assessment)
   -- Learn from safe code to reduce false positives
   local features = self:ExtractCodeFeatures(code, assessment.caller)
   local target_class = 0 -- Normal class
   
   self:TrainNeuralNetwork(features, target_class)
   
   print("[Auto Learning] Learned safe pattern to reduce false positives")
end

function AntiExploit:ExtractFeaturesFromThreat(threat_data)
   local features = {}
   
   -- Initialize features
   for i = 1, 20 do
       features[i] = 0
   end
   
   -- Confidence score
   features[1] = threat_data.confidence or 0
   
   -- Threat type features
   if threat_data.threat_type == "HTTP_THREAT" then
       features[2] = 1
   elseif threat_data.threat_type == "CODE_EXECUTION" then
       features[3] = 1
   elseif threat_data.threat_type == "NETWORK_EXPLOIT" then
       features[4] = 1
   end
   
   -- Indicator count
   features[5] = threat_data.indicators and #threat_data.indicators / 10 or 0
   
   -- Additional threat-specific features
   if threat_data.url then
       features[6] = string.len(threat_data.url) / 100
   end
   
   if threat_data.code then
       features[7] = string.len(threat_data.code) / 1000
   end
   
   return features
end

function AntiExploit:DetermineThreatClass(threat_type, confidence)
   -- Determine threat classification
   -- 0: Normal, 1: Suspicious, 2: Likely Exploit, 3: Confirmed Threat
   
   if confidence >= 0.9 then
       return 3 -- Confirmed threat
   elseif confidence >= 0.7 then
       return 2 -- Likely exploit
   elseif confidence >= 0.4 then
       return 1 -- Suspicious
   else
       return 0 -- Normal
   end
end

function AntiExploit:CalculateNetworkAccuracy()
   -- Simple accuracy calculation based on recent predictions
   if self.AIBrain.decision_engine.decision_accuracy then
       local correct = 0
       local total = 0
       
       for _, decision in pairs(self.AIBrain.decision_engine.decision_accuracy) do
           total = total + 1
           if decision.correct then
               correct = correct + 1
           end
       end
       
       if total > 0 then
           return correct / total
       end
   end
   
   return 0.5 -- Default accuracy
end

function AntiExploit:OptimizeNeuralNetwork()
   -- Optimize neural network based on performance
   if self.AIBrain.neural_network.training_samples > 100 then
       local accuracy = self:CalculateNetworkAccuracy()
       self.AIBrain.neural_network.accuracy = accuracy
       
       if accuracy < 0.7 then
           -- Poor accuracy - increase learning rate temporarily
           self.AIBrain.neural_network.learning_rate = math.min(0.05, self.AIBrain.neural_network.learning_rate * 1.2)
       elseif accuracy > 0.95 then
           -- Great accuracy - decrease learning rate for stability
           self.AIBrain.neural_network.learning_rate = math.max(0.001, self.AIBrain.neural_network.learning_rate * 0.8)
       end
   end
end