--[[
    Pattern Learning Module
    Learns and updates threat patterns
]]

function AntiExploit:UpdatePatternMemory(pattern_type, pattern_data)
    -- Update pattern memory for future detection
    if not self.AIBrain.pattern_memory[pattern_type] then
        self.AIBrain.pattern_memory[pattern_type] = {}
    end
    
    table.insert(self.AIBrain.pattern_memory[pattern_type], {
        data = pattern_data,
        timestamp = os.time(),
        confidence = pattern_data.confidence or 0
    })
    
    -- Keep only recent patterns (last 100)
    if #self.AIBrain.pattern_memory[pattern_type] > 100 then
        table.remove(self.AIBrain.pattern_memory[pattern_type], 1)
    end
end

function AntiExploit:AnalyzeNewPatterns()
    print("[Pattern Analysis] Analyzing new threat patterns...")
    
    -- Analyze collected patterns
    if self.ThreatIntelligence and self.ThreatIntelligence.new_patterns then
        local pattern_count = #self.ThreatIntelligence.new_patterns
        if pattern_count > 0 then
            print("[Pattern Analysis] Found " .. pattern_count .. " new patterns")
            
            -- Process new patterns
            for _, pattern in ipairs(self.ThreatIntelligence.new_patterns) do
                -- Add to threat database if confident
                if not table.HasValue(self.ThreatDatabase.network_signatures, pattern) then
                    table.insert(self.ThreatDatabase.network_signatures, pattern)
                end
            end
        end
    end
end

function AntiExploit:LearnSafePattern(pattern_type, pattern_name, addon_name)
    if not self.LearnedPatterns then
        self.LearnedPatterns = {hooks = {}, networks = {}, addons = {}}
    end
    
    -- Ensure sub-tables exist
    if not self.LearnedPatterns.hooks then
        self.LearnedPatterns.hooks = {}
    end
    if not self.LearnedPatterns.networks then
        self.LearnedPatterns.networks = {}
    end
    if not self.LearnedPatterns.addons then
        self.LearnedPatterns.addons = {}
    end
    
    if pattern_type == "hook" then
        self.LearnedPatterns.hooks[pattern_name] = {
            addon = addon_name,
            learned_at = os.time(),
            trust_score = 0.8
        }
    end
    
    -- Mark addon as safe
    if not self.LearnedSafeAddons then
        self.LearnedSafeAddons = {}
    end
    self.LearnedSafeAddons[addon_name] = true
    
    print("[Self-Learning] Learned safe pattern: " .. pattern_name .. " from " .. addon_name)
end

function AntiExploit:IsLearnedSafeHook(identifier)
    -- Nil kontrolü ekle
    if not self.LearnedPatterns then
        return false
    end
    
    if not self.LearnedPatterns.hooks then
        return false
    end
    
    if self.LearnedPatterns.hooks[identifier] then
        return true
    end
    
    return false
end

function AntiExploit:IdentifyAddonFromHook(hook_name)
    -- Hook names to addon mapping
    local addon_patterns = {
        ["^ULX"] = "ulx",
        ["^FAdmin"] = "fadmin",
        ["^SAM"] = "sam",
        ["^DarkRP"] = "darkrp",
        ["^pCasino"] = "pcasino",
        ["^VCMod"] = "vcmod",
        ["^Photon"] = "photon",
        ["^Refund"] = "refund",
        ["^OpenPermissions"] = "openpermissions"
    }
    
    for pattern, addon in pairs(addon_patterns) do
        if string.find(hook_name, pattern) then
            return addon
        end
    end
    
    return "unknown"
end

function AntiExploit:IdentifyAddonFromSource(source)
    if not source then return "unknown" end
    
    -- Try to extract addon name from file path
    local addon_match = string.match(source, "addons/([^/]+)")
    if addon_match then
        return addon_match
    end
    
    -- Check for known patterns in path
    if string.find(source, "openpermissions") then
        return "openpermissions"
    elseif string.find(source, "refund") then
        return "refund"
    end
    
    return "unknown"
end

function AntiExploit:IsAddonSafe(addon_name)
    -- Check learned safe addons
    if self.LearnedSafeAddons and self.LearnedSafeAddons[addon_name] then
        return true
    end
    
    -- Known safe addon list (genişletildi)
    local safe_addons = {
        "ulx", "fadmin", "sam", "darkrp", "pcasino",
        "vcmod", "photon", "wiremod", "pac3",
        "openpermissions", "refund", "awarn3", "xenin",
        "gas", "billy", "svmod", "textscreens",
        "base", "sandbox" -- Gamemode base files
    }
    
    -- Gamemode files are always safe
    if addon_name == "gamemode" or addon_name == "base" then
        return true
    end
    
    return table.HasValue(safe_addons, addon_name:lower())
end