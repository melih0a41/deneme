--[[
    Threat Intelligence Module
    Manages threat intelligence and autonomous decisions
]]

function AntiExploit:UpdateThreatIntelligence(threat_type, threat_data, action)
    -- Nil kontrolÃ¼ ekle
    if not threat_type or not threat_data then
        print("[ThreatIntel] Warning: Invalid parameters passed to UpdateThreatIntelligence")
        return
    end
    
    -- Update threat intelligence database
    if not self.ThreatIntelligence then
        self.ThreatIntelligence = {
            threats = {},
            actions = {},
            patterns = {},
            new_patterns = {}
        }
    end
    
    -- Log threat
    table.insert(self.ThreatIntelligence.threats, {
        type = threat_type,
        data = threat_data,
        action = action,
        timestamp = os.time()
    })
    
    -- Update patterns if new pattern detected
    if threat_data and threat_data.indicators then
        for _, indicator in ipairs(threat_data.indicators) do
            if not table.HasValue(self.ThreatIntelligence.patterns, indicator) then
                table.insert(self.ThreatIntelligence.patterns, indicator)
                table.insert(self.ThreatIntelligence.new_patterns, indicator)
            end
        end
    end
end

function AntiExploit:HandleAutonomousThreat(threat_type, threat_data)
    local confidence = threat_data.confidence
    
    -- Determine autonomous action
    if confidence >= AntiExploit.Config.AUTO_BAN_THRESHOLD then
        self:AutonomousBan(threat_type, threat_data)
    elseif confidence >= AntiExploit.Config.AUTO_KICK_THRESHOLD then
        self:AutonomousKick(threat_type, threat_data)
    elseif confidence >= AntiExploit.Config.AUTO_WARN_THRESHOLD then
        self:AutonomousWarn(threat_type, threat_data)
    end
    
    -- Auto-learning from threats
    if AntiExploit.Config.AUTO_LEARNING and confidence > AntiExploit.Config.AUTO_LEARN_THRESHOLD then
        self:LearnFromThreat(threat_type, threat_data)
    end
    
    -- Log for analysis
    self:LogAutonomousAction(threat_type, threat_data, confidence)
end

function AntiExploit:AutonomousBan(threat_type, threat_data)
    -- Find associated player if possible
    local ply = self:FindThreatSource(threat_data)
    
    if IsValid(ply) then
        local ban_reason = string.format("Autonomous AI: %s detected (%.1f%% confidence)", 
                                       threat_type, threat_data.confidence * 100)
        ply:Ban(0, ban_reason)
        
        print(string.format("[Autonomous Ban] %s banned: %s", ply:Nick(), ban_reason))
    end
    
    -- Update threat intelligence
    self:UpdateThreatIntelligence(threat_type, threat_data, "BAN")
end

function AntiExploit:AutonomousKick(threat_type, threat_data)
    local ply = self:FindThreatSource(threat_data)
    
    if IsValid(ply) then
        local kick_reason = string.format("Autonomous AI: %s detected (%.1f%% confidence)", 
                                        threat_type, threat_data.confidence * 100)
        ply:Kick(kick_reason)
        
        print(string.format("[Autonomous Kick] %s kicked: %s", ply:Nick(), kick_reason))
    end
    
    self:UpdateThreatIntelligence(threat_type, threat_data, "KICK")
end

function AntiExploit:AutonomousWarn(threat_type, threat_data)
    local ply = self:FindThreatSource(threat_data)
    
    if IsValid(ply) then
        ply:ChatPrint(string.format("[AI Security] Suspicious activity detected: %s", threat_type))
        print(string.format("[Autonomous Warning] %s warned for %s", ply:Nick(), threat_type))
    end
end

function AntiExploit:FindThreatSource(threat_data)
    -- Try to find the player associated with the threat
    if threat_data.player and IsValid(threat_data.player) then
        return threat_data.player
    end
    
    -- Check if threat data contains player reference
    if threat_data.ply and IsValid(threat_data.ply) then
        return threat_data.ply
    end
    
    -- Last resort - find first non-admin player
    for _, ply in ipairs(player.GetAll()) do
        if IsValid(ply) and not ply:IsAdmin() then
            return ply
        end
    end
    
    return nil
end

function AntiExploit:InitializeAutoOptimization()
    -- Auto-optimization timer
    timer.Create("AntiExploit_AutoOptimization", AntiExploit.Config.AUTO_OPTIMIZATION_INTERVAL, 0, function()
        self:PerformAutoOptimization()
    end)
    
    print("[Auto-Optimization] ðŸš€ System initialized")
end

function AntiExploit:PerformAutoOptimization()
    -- Auto-adjust thresholds based on performance
    self:AutoAdjustThresholds()
    
    -- Optimize neural network parameters
    self:OptimizeNeuralNetwork()
    
    -- Update threat database
    self:UpdateThreatDatabase()
    
    -- Performance tuning
    self:AutoTunePerformance()
    
    print("[Auto-Optimization] System optimized automatically")
end

function AntiExploit:AutoAdjustThresholds()
    local performance_metrics = self:CalculatePerformanceMetrics()
    
    -- If too many false positives, increase thresholds
    if performance_metrics.false_positive_rate > 0.1 then
        AntiExploit.Config.AUTO_WARN_THRESHOLD = math.min(0.9, AntiExploit.Config.AUTO_WARN_THRESHOLD + 0.02)
        AntiExploit.Config.AUTO_KICK_THRESHOLD = math.min(0.95, AntiExploit.Config.AUTO_KICK_THRESHOLD + 0.02)
        AntiExploit.Config.AUTO_BAN_THRESHOLD = math.min(0.98, AntiExploit.Config.AUTO_BAN_THRESHOLD + 0.01)
        print("[Auto-Tune] Thresholds increased to reduce false positives")
    end
    
    -- If missing threats, decrease thresholds slightly
    if performance_metrics.detection_rate < 0.9 then
        AntiExploit.Config.AUTO_WARN_THRESHOLD = math.max(0.6, AntiExploit.Config.AUTO_WARN_THRESHOLD - 0.01)
        AntiExploit.Config.AUTO_KICK_THRESHOLD = math.max(0.75, AntiExploit.Config.AUTO_KICK_THRESHOLD - 0.01)
        print("[Auto-Tune] Thresholds decreased to improve detection")
    end
end

function AntiExploit:AutoTunePerformance()
    -- Monitor system performance
    local fps = 1 / engine.TickInterval()
    local memory_usage = collectgarbage("count")
    local player_count = #player.GetAll()
    
    -- Check system performance
    if fps < AntiExploit.Config.MIN_FPS_THRESHOLD then
        print("[System Health] Low FPS detected: " .. math.Round(fps, 1))
        self:ReduceMonitoringLoad()
    end
    
    if memory_usage > AntiExploit.Config.MAX_MEMORY_MB * 1024 then
        print("[System Health] High memory usage: " .. math.Round(memory_usage/1024, 1) .. "MB")
        collectgarbage("collect")
    end
    
    -- Log system status
    if player_count > 0 and AntiExploit.Config.VERBOSE_LOGGING then
        print(string.format("[System Health] FPS: %.1f | Memory: %.1fMB | Players: %d", 
                           fps, memory_usage/1024, player_count))
    end
end

function AntiExploit:ReduceMonitoringLoad()
    if timer.Exists("AntiExploit_PlayerMonitoring") then
        timer.Adjust("AntiExploit_PlayerMonitoring", 2)
        print("[Auto-Tune] Reduced monitoring frequency due to low FPS")
    end
end